
## CRUD操作  
> 值得注意的一点是，总不能每次遇到需求都是有新表的   
> 譬如某公司有人家的数据库，让连接人家公司的数据，总不能自己再新创建表结构   

###  关于表连接   

- 像上一节中创建表的时候需要指定`await Tortoise.generate_schemas()`
```python
from tortoise import run_async

class Student(Model):
	...
class XXX():
	...
async def  init():
    await Tortoise.init(
        db_url='mysql://niko:HHCzio20@localhost:3306/fastapidb1',
        modules={
            "models":['models']
        }
    )
    await Tortoise.generate_schemas() #important:注意这里必须加上,不加上表就不会生成

if __name__ == '__main__':
    run_async(init())
```

- 但是如果我们只是单纯的想连接已经创建的表进行操作，那么便不必创建新表，而是连接即可
- 需要注意的是，即使是单纯的连接也是需要把需要连接的表的models关于表的定义的class复制下来的
```python
register_tortoise(
    app,
    db_url='mysql://niko:HHCzio20@localhost:3306/fastapidb1',
    modules={'models': ['models']},
    generate_schemas=False
)

```

### 增加学生信息
```python
class Student(BaseModel):
    name: str
    age: int
    address: str
    phone: Annotated[str,Field(pattern=r'^1[3-9]\d{9}$')]
    address: str


@app.post('/stu', description='添加学生')
async def addstu(stu: Annotated[Student, Form()]):
    stu_new = await Student.create(
        name=stu.name,
        age=stu.age
    )
    # tips:因为和档案有一对一关系，所以需要连同档案的也要创建
    profile = await StudentProfile.create(
        address=stu.address,
        phonenum=stu.phone,
    )
    # tips:然后指定学生信息的档案信息
    stu_new.profile = profile  # important:注意这里相当于修改数据
    # important：所以需要save,如果只是创建而不是我们这样后面又进行类似修改操作的参数指定的话就不需要save
    stu_new.save()
    return {
        'status': True,
        'msg': f'学生-{stu_new.name}信息录入成功'
    }

```

```python
#tips:学生表
class Student(Model):
    stuid:int=fields.IntField(pk=True)
    name:str=fields.CharField(max_length=50)
    age:int=fields.IntField(validators=[agevalidator,])
    profile:str=fields.OneToOneField('models.StudentProfile',on_delete=fields.CASCADE,related_name='student')
    #tips:related_name表示反向查询引用标识，譬如知道档案想要查询学生表的时候就可以通过它来查到，和flask中的backref一样的，
    # 如StudentProfile对象.student.name,这样就可以通过档案表找到学生信息
    #

#tips:学生档案表
class StudentProfile(Model):
    pfid:int=fields.IntField(pk=True)
    address:str=fields.CharField(max_length=50) #档案保存地址
    phonenum:str=fields.CharField(validators=[phonevalidator])

```
>  需要注意一点可能是会报错的，因为创建表的一对一关系的时候我们没有设置Student的profile为空   
> 这样我们创建的时候 
```python 
await Student.create(
        name=stu.name,
        age=stu.age
    ) 
```
> 就会触发报错，所以导致我们之后想走指定`stu_new.profile = profile`的逻辑会走不通 

解决方式其实很简单，允许profile为空即可

```python
class Student(Model):
    stuid: int = fields.IntField(pk=True)
    name: str = fields.CharField(max_length=50)
    age: int = fields.charField(validators=[agevalidator, ])
    profile: str = fields.OneToOneField('models.StudentProfile', on_delete=fields.CASCADE, related_name='student',
                                        null=True)

# tips:related_name表示反向查询引用标识，譬如知道档案想要查询学生表的时候就可以通过它来查到，和flask中的backref一样的，
# 如StudentProfile对象.student.name,这样就可以通过档案表找到学生信息
#
```
