你遇到的错误是：

```
UnicodeEncodeError: 'latin-1' codec can't encode characters in position 21-28: ordinal not in range(256)
```

### 错误原因分析：

这个错误发生在 `FileResponse` 尝试将你传入的 **headers** 中的 `filename` 编码为 Latin-1（ISO-8859-1）时。  
而你的文件名是：

```python
"尚硅谷高级技术之Shell.pdf"
```

其中包含 **中文字符**，这些字符的 Unicode 码点超出了 Latin-1 编码的范围（0–255），所以无法被编码，从而抛出异常。

---

### 解决方案

HTTP 标准中，`Content-Disposition` 的 `filename` 字段 **不支持直接使用非 ASCII 字符**（如中文）。  
但你可以通过 **RFC 5987** 规范对文件名进行 **UTF-8 编码 + 百分号编码（URL encoding）**，并使用 `filename*` 参数来传递。

#### ✅ 正确做法：同时提供 ASCII 兼容的 `filename` 和 UTF-8 编码的 `filename*`

修改你的代码如下：

```python
import urllib.parse
from fastapi import FastAPI
from fastapi.responses import FileResponse

app = FastAPI()

@app.get('/getpdffile')
async def getpdffile():
    filepath = './demofile/尚硅谷高级技术之Shell.pdf'
    filename = filepath.split('/')[-1]

    # 对中文文件名进行 URL 编码（UTF-8）
    encoded_filename = urllib.parse.quote(filename, safe='')

    return FileResponse(
        path=filepath,
        status_code=200,
        media_type="application/pdf",
        headers={
            "Content-Disposition": f"attachment; filename={filename.encode('utf-8').decode('latin-1', errors='replace')}; filename*=UTF-8''{encoded_filename}"
        }
    )
```

> ⚠️ 但注意：`filename={...}` 部分如果直接放中文，在某些浏览器或中间件中仍可能出问题。更安全的做法是：
>
> - `filename`：提供一个 ASCII 兼容的 fallback 名字（比如 `document.pdf`）
> - `filename*`：提供真正的 UTF-8 编码文件名

#### ✅ 推荐写法（最兼容）：

```python
@app.get('/getpdffile')
async def getpdffile():
    filepath = './demofile/尚硅谷高级技术之Shell.pdf'
    original_filename = "尚硅谷高级技术之Shell.pdf"

    # ASCII fallback（可选：用英文名或简单名）
    ascii_filename = "document.pdf"

    # URL 编码 UTF-8 文件名
    encoded_filename = urllib.parse.quote(original_filename, safe='')

    return FileResponse(
        path=filepath,
        status_code=200,
        media_type="application/pdf",
        headers={
            "Content-Disposition": f"attachment; filename={ascii_filename}; filename*=UTF-8''{encoded_filename}"
        }
    )
```

这样：
- 老旧客户端会使用 `filename=document.pdf`
- 现代浏览器（支持 RFC 5987）会使用 `filename*` 显示正确的中文名

---

### 补充说明

- `urllib.parse.quote()` 会把中文转成 `%E5%B0%9A...` 这样的格式，符合 `filename*` 的要求。
- `filename*` 的语法是：`filename*=charset''encoded_name`，例如：`filename*=UTF-8''%E5%B0%9A...`
- 不要试图用 `.encode('latin-1')` 强制转换中文，这一定会失败。

---

### 最终建议

如果你确定所有用户都使用现代浏览器（Chrome/Firefox/Edge等），也可以只用 `filename*`，但为了最大兼容性，**同时提供 `filename` 和 `filename*` 是最佳实践**。

---

✅ 修改后即可解决 `UnicodeEncodeError` 并正确下载带中文名的文件。