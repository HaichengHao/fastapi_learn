# 本节代码也在05多表关系中实现  

## 定义返回session
因为之前我们都是直接crud,并未结合视图函数来进行操作  
那么当我们在视图中进行session操作数据库的时候就需要传入session了  
既然如此，那么我们就要将获取session的操作定义为一个可以调用的方法  
并使用生成器生成session,那么每次调用时就直接获得,可以提高效率  

databases.py  
```python

from models.employee import Employee
from models.department import Department
from sqlalchemy import *
from sqlalchemy.orm import sessionmaker, Session
from models.employee import Employee, GenderValue,IDCard
engin  = create_engine(
    url='mysql+pymysql://niko:HHCzio20@localhost:3306/fastapidb4',
    echo=False
)

def get_session():
    session = Session(bind=engin)
    try:
        yield session #important:返回生成对象session并在此暂停,等下次继续拿session对象进行数据库会话操作的时候就在此处继续,非常高效
    finally:
        session.close()
```
> 由于我这次并没有使用sessionmaker和with管理上下文,所以我们在视图中进行crud的操作时,部分操作需要手动session.commit()


## 定义schema  
我们用sqlalchemy建表和sqlmodel不一样,它更像我们之前学的tortoiseorm,需要另外建立schema

定义的schema中的字段要与数据库的字段类型相互对应    
schemas.py   
```python
from decimal import Decimal
from datetime import date
from pydantic import BaseModel,Field
from models.employee import GenderValue

class Empschema(BaseModel):
    id:int=Field(description='员工ID,添加数据的时候不用传递')
    name:str=Field(description='姓名')
    salary:Decimal=Field(description='薪资',default=None)
    bonus:int=Field(description='奖金',default=None)
    gender:GenderValue=Field(description='性别')
    is_leave:bool=Field(description='是否离职,True为离职',default=False) #默认不离职
    dep_id:int = Field(description='员工所属部门id',default=None)
    entry_date:date=Field(description='入职时间',default=None)

    #important：这是关键,需要重写才可以实现sqlalchemy的模型和pydantic模型之间的转换
    class Config:
        from_attributes=True


```
> 注意定义schema需要重写一个类Config并指定from_attributes=True
> 为什么重写？  
> 因为sqlalchemy中sqlmodel和pydantic的model是不互通的,要想操作完数据库并返回JSON必须做这样的操作  


--- 

## 接下来要定义路由  
views.py  
一定要注意.first()这个Result对象方法,不然只是查询没有返回值,if判断就走不通,数据就插入不到数据库
```python
from http.client import HTTPException
from fastapi import APIRouter,Depends,HTTPException
from sqlalchemy import Select
from sqlalchemy.orm import Session
from typing import Annotated

from databases import get_session
from schemas import Empschema
from models import Employee

emp_apirt = APIRouter(prefix='/api/employee',tags=['员工管理'])

@emp_apirt.get('/')
async def getemp():
    pass

@emp_apirt.post('/emp/')
async def create_emp(employee:Empschema,session:Annotated[Session,Depends(get_session)]):
    #step1:先判断数据库中有没有重复的数据,即先进行查询
    is_emp =  session.execute(Select(Employee.name).where(Employee.name==employee.name)).first() #important:注意这里必须返回值,这里用.first()
    if is_emp: #tips:如果不为空,即已存在重复名字的员工
        raise HTTPException(status_code=405,detail='重复录入,已经存在该员工的信息')

    #tips:需要把Pydantic的模型对象(Empschema)转换为ORM的模型对象(Employee),
    #important:所以为了解决这个问题,我们刚才在定义Empschema的时候重写了Config将其设置为了from_attributes=True
    db_emp = Employee(**employee.model_dump()) #tips:这里和tortoiseorm差不多
    #tips:其实这里就跟curd操作当中创建员工对象的操作是一样的,就是新建一个员工对象然后**employee.model_dump()就是解包赋值

    session.add(db_emp)
    session.commit()  #important:之前我们使用的是sessionmaker来做的,所以会自动提交,但这次是我们手动管理session,所以需要提交




```


## 返回我们想查看的插入的数据    
由于之前设置了from_attributes=True,那么我们只需指定response_model为制定的schema  
在返回时则是返回数据库中新建的对象db_emp,但是它会转成pydantic类型的!!
```python
@emp_apirt.post('/emp/',description='添加员工',response_model=Empschema)
async def create_emp(employee:Empschema,session:Annotated[Session,Depends(get_session)]):
    #step1:先判断数据库中有没有重复的数据,即先进行查询
    is_emp =  session.execute(Select(Employee.name).where(Employee.name==employee.name)).first()
    if is_emp: #tips:如果不为空,即已存在重复名字的员工
        raise HTTPException(status_code=405,detail='重复录入,已经存在该员工的信息')

    #tips:需要把Pydantic的模型对象(Empschema)转换为ORM的模型对象(Employee),
    #important:所以为了解决这个问题,我们刚才在定义Empschema的时候重写了Config将其设置为了from_attributes=True
    db_emp = Employee(**employee.model_dump()) #tips:这里和tortoiseorm差不多
    #tips:其实这里就跟curd操作当中创建员工对象的操作是一样的,就是新建一个员工对象然后**employee.model_dump()就是解包赋值

    session.add(db_emp)
    session.commit()  #important:之前我们使用的是sessionmaker来做的,所以会自动提交,但这次是我们手动管理session,所以需要提交
    return db_emp

```  
到docs中操作查看结果,成功!!

![img.png](img.png)  

![img_1.png](img_1.png)


## CRUD操作   
刚才进行了数据插入测试,但是某些细节未优化不够严谨,其实允许为空的字段都应该加上Optional,现在进一步优化   
这次优化了dep_id为可选项,这样我们进行查询后的员工如果没有分配部门也不会报错而是可以正常返回  

并且这次定义了返回员工详细信息的schema,以及部门的schema,这样就可以匹配上sqlmodel中的员工表的dep_name是Department表对象的形式
schemas.py  
```python
from datetime import date
from typing import Optional

from pydantic import BaseModel,Field
from models.employee import GenderValue
from  models.department import Department
class Empschema(BaseModel):
    id:int=Field(description='员工ID,添加数据的时候不用传递',default=None)
    name:str=Field(description='姓名')
    salary:Optional[float]=Field(description='薪资',default=None)
    bonus:int=Field(description='奖金',default=None)
    gender:GenderValue=Field(description='性别',default=GenderValue.MALE)
    is_leave:bool=Field(description='是否离职,True为离职',default=False) #默认不离职
    dep_id:Optional[int] = Field(description='员工所属部门id',default=None)
    entry_date:date=Field(description='入职时间',default=None)

    #important：这是关键,需要重写才可以实现sqlalchemy的模型和pydantic模型之间的转换
    class Config:
        from_attributes=True #important:有了这个配置才能把ORM模型转换为Pydantic模型对象



#tips:定义创建部门的schema,方便下面返回详细信息的时候调用此表的schema
class  DepartmentSchema(BaseModel):
    id:int=Field(description='员工部门的ID,添加数据的时候不要传',default=None)
    name:str=Field(description='部门名称',default=None)
    city:str=Field(description='部门所在城市的名称',default=None)

    class  Config:
        from_attributes=True

#tips：获取员工的详细信息,包含部门名称,只需要继承上面的Schema并新增一个部门名称即可,注意也要与employee表保持一致
# important:注意因为我们在employee表中定义的dep_name是属于Department类型的,所以这里也得是Department类型

class DetailEMPINFO(Empschema):
    '''
    响应员工信息的模型类,包含该员工的所属部门
    '''
    dep_name:Optional[DepartmentSchema]= Field(description='所属部门',default=None)
    class Config:
        from_attributes=True

```

views.py   
```python
#tips:根据传入的员工id返回详细的员工信息
@emp_apirt.get('/emp/{id}', response_model=DetailEMPINFO)
async def getemp(id: int, session: Annotated[Session, Depends(get_session)]):
    result = session.get(Employee, id)
    if result:
        return result
    else:
        raise HTTPException(status_code=403, detail='未查讯到讯息')

```

## 分页查询    
```python

@emp_apirt.get('/emp',response_model=list[DetailEMPINFO],description='查询所有员工列表')
async def getall_emps(session: Annotated[Session, Depends(get_session)],offset:int=Query(title='输入的是offset',default=0),page_size:int=Query(default=5,description='每页最多显示的数量')):

    return session.scalars(Select(Employee).offset(offset).limit(page_size)).all()


```

