当然可以！下面是一个 **完整、简洁、可运行** 的示例，涵盖：

- ✅ 异步 SQLAlchemy + SQLModel 模型定义  
- ✅ 异步引擎与会话管理（用于 FastAPI）  
- ✅ CRUD 操作（异步）  
- ✅ Alembic 迁移配置（同步引擎，用于建表）

---

## 📁 项目结构

```bash
fastapi_sqlmodel_async/
├── main.py                 # FastAPI app
├── models.py               # SQLModel 模型
├── database.py             # 异步数据库连接
├── alembic.ini
└── alembic/
    ├── env.py
    └── versions/           # 自动生成
```

---

## 1️⃣ `models.py` —— 定义模型（SQLModel）

```python
# models.py
from typing import Optional
from sqlmodel import SQLModel, Field
from datetime import datetime


class Employee(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(max_length=50, unique=True)
    salary: float
    is_active: bool = Field(default=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

> ✅ 使用 `SQLModel` 自动继承 `DeclarativeBase`，无需手动写 `Base`

---

## 2️⃣ `database.py` —— 异步引擎 & 会话

```python
# database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlmodel import SQLModel
from models import Employee  # 确保模型被导入

DATABASE_URL = "postgresql+asyncpg://nikofox:HHCzio20.@localhost:5432/nikofox"

engine = create_async_engine(DATABASE_URL, echo=True)

AsyncSessionLocal = sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)


async def init_db():
    """仅用于测试或初始化（生产中通常用 Alembic 建表）"""
    async with engine.begin() as conn:
        await conn.run_sync(SQLModel.metadata.create_all)


async def get_session():
    async with AsyncSessionLocal() as session:
        yield session
```

---

## 3️⃣ `main.py` —— FastAPI + 异步 CRUD

```python
# main.py
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.exc import IntegrityError
from sqlmodel.ext.asyncio.session import AsyncSession
from models import Employee
from database import get_session

app = FastAPI(title="Employee API")


@app.post("/employees/", response_model=Employee)
async def create_employee(employee: Employee, session: AsyncSession = Depends(get_session)):
    session.add(employee)
    try:
        await session.commit()
        await session.refresh(employee)
    except IntegrityError:
        await session.rollback()
        raise HTTPException(status_code=400, detail="Employee name already exists")
    return employee


@app.get("/employees/{emp_id}", response_model=Employee)
async def read_employee(emp_id: int, session: AsyncSession = Depends(get_session)):
    emp = await session.get(Employee, emp_id)
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    return emp


@app.put("/employees/{emp_id}", response_model=Employee)
async def update_employee(
    emp_id: int, updated: Employee, session: AsyncSession = Depends(get_session)
):
    db_emp = await session.get(Employee, emp_id)
    if not db_emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    emp_data = updated.model_dump(exclude_unset=True)
    for key, value in emp_data.items():
        setattr(db_emp, key, value)
    session.add(db_emp)
    await session.commit()
    await session.refresh(db_emp)
    return db_emp


@app.delete("/employees/{emp_id}")
async def delete_employee(emp_id: int, session: AsyncSession = Depends(get_session)):
    emp = await session.get(Employee, emp_id)
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    await session.delete(emp)
    await session.commit()
    return {"message": "Deleted"}
```

---

## 4️⃣ 配置 Alembic（用于迁移）

### 安装依赖
```bash
pip install fastapi uvicorn sqlalchemy[asyncio] asyncpg psycopg2-binary alembic sqlmodel
```

> ⚠️ 注意：**Alembic 需要 `psycopg2`（同步驱动）来执行迁移**，即使你用的是异步应用！

---

### 初始化 Alembic
```bash
alembic init alembic
```

---

### 修改 `alembic.ini`
找到 `sqlalchemy.url = ...` 行，改为你的 **同步 URL**：

```ini
# alembic.ini
sqlalchemy.url = postgresql+psycopg2://nikofox:HHCzio20.@localhost:5432/nikofox
```

---

### 修改 `alembic/env.py`

```python
# alembic/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
from models import SQLModel  # ← 导入你的模型

# this is the Alembic Config object
config = context.config

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = SQLModel.metadata

def run_migrations_offline():
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    with connectable.connect() as connection:
        context.configure(connection=connection, target_metadata=target_metadata)
        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
```

---

## 5️⃣ 生成并应用迁移

```bash
# 1. 生成迁移文件
alembic revision --autogenerate -m "create employee table"

# 2. 应用迁移（建表）
alembic upgrade head
```

✅ 此时数据库中已创建 `employee` 表。

---

## 6️⃣ 启动服务

```bash
uvicorn main:app --reload
```

访问：
- http://127.0.0.1:8000/docs
- 尝试 POST `/employees/` 创建员工

---

## ✅ 关键点总结

| 组件 | 引擎类型 | 用途 |
|------|--------|------|
| `database.py` | `postgresql+asyncpg://`（异步） | FastAPI 运行时 CRUD |
| `alembic/env.py` | `postgresql+psycopg2://`（同步） | Alembic 执行 DDL（建表） |
| `models.py` | 无引擎 | 共享模型定义 |

> 💡 **同一个模型，两种引擎**：这是标准做法！SQLAlchemy 模型本身不绑定引擎，引擎只在执行时使用。

---

## 🧪 测试建议

1. 先运行 `alembic upgrade head` 确保表存在
2. 再启动 FastAPI
3. 不要混用异步引擎和 Alembic（Alembic 不支持 asyncpg）

---

这个示例可以直接复制使用，只需替换你的数据库用户名/密码。如果你希望我打包成 GitHub 仓库模板，也可以告诉我！😊