当然可以！以下是 **SQLModel 中表关系（一对一、一对多、多对多）的速查表**，专为 FastAPI + SQLModel 开发者设计，包含清晰的模型定义、外键设置、关联查询方式和注意事项。所有代码均可直接运行，适合学习与项目参考。

---

# 📘 SQLModel 表关系速查表（一对一 / 一对多 / 多对多）

> ✅ 基于 **SQLModel v0.0.22+**  
> ✅ 支持 **异步（Async）** 查询  
> ✅ 使用 `sqlmodel.Relationship` 实现 ORM 关联

---

## 通用说明

- 所有关系通过 `Relationship()` 声明
- 外键使用 `Field(foreign_key="表名.字段")`
- **反向关系需手动指定 `back_populates`**
- 查询关联数据需使用 `.exec(select(...).options(selectinload(...)))` 或显式加载（见下文）

---

## 一、一对一（One-to-One）

### 场景：User ↔ Profile

```python
from sqlmodel import SQLModel, Field, Relationship
from typing import Optional

class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str

    # 一对一：一个 User 有一个 Profile
    profile: Optional["Profile"] = Relationship(back_populates="user")

class Profile(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    bio: str
    user_id: int = Field(foreign_key="user.id", unique=True)  # 👈 unique=True 是关键！

    user: Optional[User] = Relationship(back_populates="profile")
```

> 🔑 **关键点**：
> - `user_id` 上加 `unique=True` 确保一对一
> - 双向 `back_populates`

### 查询示例（异步）

```python
# 获取用户及其 profile
statement = select(User).where(User.id == 1)
user = (await session.exec(statement)).first()
# 注意：默认不自动加载关联对象！需显式加载或使用 selectinload（见下文）
```

---

## 二、一对多（One-to-Many）

### 场景：Team → Users（一个团队有多个用户）

```python
from sqlmodel import SQLModel, Field, Relationship
from typing import List, Optional

class Team(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str

    # 一对多：一个 Team 有多个 User
    users: List["User"] = Relationship(back_populates="team")

class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str
    team_id: Optional[int] = Field(default=None, foreign_key="team.id")  # 可为空

    team: Optional[Team] = Relationship(back_populates="users")
```

> 🔑 **关键点**：
> - “多”方（User）持有外键 `team_id`
> - “一”方（Team）用 `List[User]`
> - 外键可为 `Optional` 表示可不属于任何团队

---

## 三、多对多（Many-to-Many）

### 场景：User ↔ Role（用户有多个角色，角色被多个用户拥有）

> 💡 SQLModel **不支持隐式中间表**，必须**显式定义关联表模型**

```python
from sqlmodel import SQLModel, Field, Relationship
from typing import List, Optional

# 主模型
class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str

    # 通过中间表关联
    roles: List["Role"] = Relationship(back_populates="users", link_model=UserRole)

class Role(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str  # e.g., "admin", "editor"

    users: List["User"] = Relationship(back_populates="roles", link_model=UserRole)

# 显式中间表（必须定义！）
class UserRole(SQLModel, table=True):
    user_id: int = Field(foreign_key="user.id", primary_key=True)
    role_id: int = Field(foreign_key="role.id", primary_key=True)
```

> 🔑 **关键点**：
> - 必须创建 `UserRole` 模型作为中间表
> - 使用 `link_model=UserRole` 指定关联表
> - 中间表主键为复合主键（两个外键）

---

## 四、关联数据查询（异步）

SQLModel 默认**不会自动加载关联对象**（避免 N+1 问题），需显式加载。

### 方法 1：使用 `selectinload`（推荐）

```python
from sqlalchemy.orm import selectinload
from sqlmodel import select

# 一对一：加载 user + profile
statement = select(User).options(selectinload(User.profile)).where(User.id == 1)
user = (await session.exec(statement)).first()
print(user.profile.bio)

# 一对多：加载 team + 所有 users
statement = select(Team).options(selectinload(Team.users)).where(Team.id == 1)
team = (await session.exec(statement)).first()
for u in team.users:
    print(u.name)

# 多对多：加载 user + roles
statement = select(User).options(selectinload(User.roles)).where(User.id == 1)
user = (await session.exec(statement)).first()
for r in user.roles:
    print(r.name)
```

### 方法 2：手动二次查询（不推荐，易 N+1）

```python
user = await session.get(User, 1)
# ❌ 此时 user.roles 是未加载的代理对象
# ✅ 需要：
await session.refresh(user, ["roles"])  # 显式加载 roles
```

---

## 五、创建带关系的数据

### 一对一

```python
user = User(name="Alice")
profile = Profile(bio="Dev", user=user)  # 自动设置 user_id
session.add(profile)
await session.commit()
```

### 一对多

```python
team = Team(name="Backend")
user1 = User(name="Bob", team=team)
user2 = User(name="Carol", team=team)
session.add(team)
await session.commit()
```

### 多对多

```python
user = User(name="David")
admin_role = await session.get(Role, 1)
editor_role = await session.get(Role, 2)

user.roles = [admin_role, editor_role]  # 自动创建 UserRole 记录
session.add(user)
await session.commit()
```

> ✅ SQLModel 会自动管理中间表（`UserRole`）的插入/删除。

---

## 六、常见问题 & 注意事项

| 问题 | 解决方案 |
|------|--------|
| 关联对象为 `None` 或空列表 | 默认不加载！必须用 `selectinload` 或 `refresh` |
| 迁移未生成外键/中间表 | 确保在 `alembic/env.py` 中导入了**所有模型**（包括中间表） |
| 循环引用报错 | 使用字符串类型注解：`profile: Optional["Profile"] = ...` |
| 多对多无法更新 | 赋值新列表会自动同步中间表（先清空再插入） |
| 性能差（N+1） | 始终使用 `selectinload` 一次性加载 |

---

## 七、完整项目结构建议

```
models/
├── __init__.py
├── user.py        # User, Profile, UserRole
├── team.py        # Team
└── role.py        # Role
```

并在 `alembic/env.py` 中导入：

```python
# alembic/env.py
from models.user import User, Profile, UserRole
from models.team import Team
from models.role import Role
```

---

## ✅ 总结：关系定义口诀

| 关系类型 | 外键在哪 | 字段类型 | 关键参数 |
|--------|--------|--------|--------|
| 一对一 | “拥有方”（如 Profile） | `Optional[Model]` | `unique=True` on FK |
| 一对多 | “多”方（如 User） | “一”方：`List[Model]`“多”方：`Optional[Model]` | `back_populates` 双向 |
| 多对多 | 中间表（显式定义） | 双方均为 `List[Model]` | `link_model=中间表` |

---

你可以将此速查表保存为 `sqlmodel-relationships-cheatsheet.md`，配合前一份 **SQLModel + Alembic 速查表** 使用，快速掌握完整数据建模能力。

如果需要我提供一个**包含三种关系的完整可运行示例项目**（含 FastAPI 路由、Alembic 迁移、测试数据），也可以告诉我！